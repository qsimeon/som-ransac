"""\nDemo script for using a Kohonen Self-Organizing Map (SOM) to perform robust model fitting\nas an alternative to traditional RANSAC.\n\nThis script demonstrates:\n 1. Generating synthetic data for a 2D line with outliers.\n 2. Normalizing the data.\n 3. Creating and configuring a SOM to detect outliers and fit a model.\n 4. Evaluating outlier detection and model fitting performance.\n\nAuthor: Your Name\nDate: 2023-10\n"""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Import from the provided project modules (must exist in the same directory structure).\n# These imports must match the EXACT signatures as described.\nfrom core import SOMConfig, KohonenSOM, SOMModelFitter\nfrom utils import (\n    normalize_data,\n    denormalize_data,\n    fit_line_2d,\n    generate_synthetic_data,\n    calculate_metrics,\n    compute_model_error,\n    estimate_optimal_map_size\n)\n\ndef main():\n    try:\n        # 1) Generate synthetic 2D line data with outliers\n        # The second return value is a boolean array indicating true inliers (True) vs outliers (False).\n        data, true_inliers = generate_synthetic_data(n_inliers=100, n_outliers=20, model_type='line', noise_std=0.1, random_seed=42)\n\n        # 2) Normalize the data (use default minmax method)\n        data_normalized, norm_params = normalize_data(data, method='minmax')\n\n        # 3) Estimate an optimal SOM map size based on data size\n        map_width, map_height = estimate_optimal_map_size(len(data_normalized), heuristic='sqrt')\n        \n        # Create a configuration for the SOM\n        # You may tune these hyperparameters for different performance\n        som_config = SOMConfig(\n            learning_rate=0.5,\n            sigma=1.0,\n            max_iter=100,\n            map_size=(map_width, map_height)\n        )\n\n        # 4) Use the SOMModelFitter as an alternative to RANSAC\n        #    This will attempt to find inliers for a line model in the data\n        model_fitter = SOMModelFitter(\n            data_normalized,\n            model_type='line',\n            som_config=som_config\n        )\n\n        # Perform the SOM-based robust fitting\n        model_fitter.fit()\n        predicted_inliers = model_fitter.get_inliers()\n        model_params = model_fitter.get_model()\n\n        # 5) Evaluate inlier classification\n        metrics = calculate_metrics(predicted_inliers, true_inliers)\n\n        # 6) Compute average model fitting error (in normalized space)\n        errors = compute_model_error(data_normalized, model_params, model_type='line')\n        mean_error_normalized = np.mean(errors)\n\n        # 7) Optionally, denormalize the model parameters to compare in original data space\n        #    We'll do a direct least-squares fit to the recovered inliers in normalized space,\n        #    then denormalize for demonstration.\n        inlier_points_normalized = data_normalized[predicted_inliers]\n        final_fit_params_normalized = fit_line_2d(inlier_points_normalized)\n\n        # Denormalize a sample of points from the fitted line to compare in original scale\n        # We'll just store the slope/intercept from final_fit_params_normalized, so let's do that:\n        slope_norm = final_fit_params_normalized['slope']\n        intercept_norm = final_fit_params_normalized['intercept']\n\n        # We'll reconstruct two points in normalized space at x=0, x=1, then denormalize to get\n        # actual slope, intercept in original space. This is a simplistic demonstration.\n        x0_norm = 0.0\n        x1_norm = 1.0\n        y0_norm = slope_norm * x0_norm + intercept_norm\n        y1_norm = slope_norm * x1_norm + intercept_norm\n        points_norm = np.array([[x0_norm, y0_norm], [x1_norm, y1_norm]])\n\n        # Denormalize these two points\n        points_denorm = denormalize_data(points_norm, norm_params)\n\n        # Extract slope, intercept in original scale\n        x0_denorm, y0_denorm = points_denorm[0]\n        x1_denorm, y1_denorm = points_denorm[1]\n        slope_denorm = (y1_denorm - y0_denorm) / (x1_denorm - x0_denorm) if (x1_denorm - x0_denorm) != 0 else np.inf\n        intercept_denorm = y0_denorm - slope_denorm * x0_denorm\n\n        # 8) Print out the results\n        print("==================== RESULTS ====================")\n        print("True inliers count:       ", np.sum(true_inliers))\n        print("Predicted inliers count:  ", np.sum(predicted_inliers))\n        print("Classification Metrics:   ", metrics)\n        print("Mean fitting error (normalized): ", mean_error_normalized)\n        print("-----------------------------------------------")\n        print("Final fitted line params (normalized space):")\n        print(f"  slope = {slope_norm:.5f}, intercept = {intercept_norm:.5f}")\n        print("Final fitted line params (original data space):")\n        print(f"  slope = {slope_denorm:.5f}, intercept = {intercept_denorm:.5f}")\n\n        # 9) Visualize the result (optional)\n        # Plot original data and color inliers vs outliers\n        fig, ax = plt.subplots(figsize=(8, 6))\n        inlier_data = data[predicted_inliers]\n        outlier_data = data[~predicted_inliers]\n        ax.scatter(inlier_data[:, 0], inlier_data[:, 1], c='blue', label='Predicted Inliers')\n        ax.scatter(outlier_data[:, 0], outlier_data[:, 1], c='red', label='Predicted Outliers')\n\n        # Plot the fitted line in original data space\n        x_vals = np.linspace(min(data[:, 0]), max(data[:, 0]), 100)\n        y_vals = slope_denorm * x_vals + intercept_denorm\n        ax.plot(x_vals, y_vals, 'g--', label='Fitted Line (SOM-based)')\n\n        ax.set_title('SOM-based Robust Line Fitting')\n        ax.set_xlabel('X')\n        ax.set_ylabel('Y')\n        ax.legend()\n        plt.show()\n\n    except Exception as e:\n        print(f"An error occurred: {e}")\n\n\nif __name__ == "__main__":\n    main()\n","requiredPackages":["numpy","matplotlib"]}